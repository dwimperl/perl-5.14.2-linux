.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "CGI::Application 3"
.TH CGI::Application 3 "2011-11-19" "perl v5.14.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
CGI::Application \- Framework for building reusable web\-applications
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&  # In "WebApp.pm"...
\&  package WebApp;
\&  use base \*(AqCGI::Application\*(Aq;
\&
\&  # ( setup() can even be skipped for common cases. See docs below. )
\&  sub setup {
\&        my $self = shift;
\&        $self\->start_mode(\*(Aqmode1\*(Aq);
\&        $self\->mode_param(\*(Aqrm\*(Aq);
\&        $self\->run_modes(
\&                \*(Aqmode1\*(Aq => \*(Aqdo_stuff\*(Aq,
\&                \*(Aqmode2\*(Aq => \*(Aqdo_more_stuff\*(Aq,
\&                \*(Aqmode3\*(Aq => \*(Aqdo_something_else\*(Aq
\&        );
\&  }
\&  sub do_stuff { ... }
\&  sub do_more_stuff { ... }
\&  sub do_something_else { ... }
\&  1;
\&
\&
\&  ### In "webapp.cgi"...
\&  use WebApp;
\&  my $webapp = WebApp\->new();
\&  $webapp\->run();
\&
\&  ### Or, in a PSGI file, webapp.psgi
\&  use WebApp;
\&  WebApp\->psgi_app();
.Ve
.SH "INTRODUCTION"
.IX Header "INTRODUCTION"
CGI::Application makes it easier to create sophisticated, high-performance,
reusable web-based applications.  CGI::Application helps makes your web
applications easier to design, write, and evolve.
.PP
CGI::Application judiciously avoids employing technologies and techniques which
would bind a developer to any one set of tools, operating system or web server.
.PP
It is lightweight in terms of memory usage, making it suitable for common \s-1CGI\s0
environments, and a high performance choice in persistent environments like
FastCGI or mod_perl.
.PP
By adding PLUG-INS as your needs grow, you can add advanced and complex
features when you need them.
.PP
First released in 2000 and used and expanded by a number of professional
website developers, CGI::Application is a stable, reliable choice.
.SH "USAGE EXAMPLE"
.IX Header "USAGE EXAMPLE"
Imagine you have to write an application to search through a database
of widgets.  Your application has three screens:
.PP
.Vb 3
\&   1. Search form
\&   2. List of results
\&   3. Detail of a single record
.Ve
.PP
To write this application using CGI::Application you will create two files:
.PP
.Vb 2
\&   1. WidgetView.pm \-\- Your "Application Module"
\&   2. widgetview.cgi \-\- Your "Instance Script"
.Ve
.PP
The Application Module contains all the code specific to your
application functionality, and it exists outside of your web server's
document root, somewhere in the Perl library search path.
.PP
The Instance Script is what is actually called by your web server.  It is
a very small, simple file which simply creates an instance of your
application and calls an inherited method, \fIrun()\fR.  Following is the
entirety of \*(L"widgetview.cgi\*(R":
.PP
.Vb 4
\&   #!/usr/bin/perl \-w
\&   use WidgetView;
\&   my $webapp = WidgetView\->new();
\&   $webapp\->run();
.Ve
.PP
As you can see, widgetview.cgi simply \*(L"uses\*(R" your Application module
(which implements a Perl package called \*(L"WidgetView\*(R").  Your Application Module,
\&\*(L"WidgetView.pm\*(R", is somewhat more lengthy:
.PP
.Vb 3
\&   package WidgetView;
\&   use base \*(AqCGI::Application\*(Aq;
\&   use strict;
\&
\&   # Needed for our database connection
\&   use CGI::Application::Plugin::DBH;
\&
\&   sub setup {
\&        my $self = shift;
\&        $self\->start_mode(\*(Aqmode1\*(Aq);
\&        $self\->run_modes(
\&                \*(Aqmode1\*(Aq => \*(Aqshowform\*(Aq,
\&                \*(Aqmode2\*(Aq => \*(Aqshowlist\*(Aq,
\&                \*(Aqmode3\*(Aq => \*(Aqshowdetail\*(Aq
\&        );
\&
\&        # Connect to DBI database, with the same args as DBI\->connect();
\&     $self\->dbh_config();
\&   }
\&
\&   sub teardown {
\&        my $self = shift;
\&
\&        # Disconnect when we\*(Aqre done, (Although DBI usually does this automatically)
\&        $self\->dbh\->disconnect();
\&   }
\&
\&   sub showform {
\&        my $self = shift;
\&
\&        # Get CGI query object
\&        my $q = $self\->query();
\&
\&        my $output = \*(Aq\*(Aq;
\&        $output .= $q\->start_html(\-title => \*(AqWidget Search Form\*(Aq);
\&        $output .= $q\->start_form();
\&        $output .= $q\->textfield(\-name => \*(Aqwidgetcode\*(Aq);
\&        $output .= $q\->hidden(\-name => \*(Aqrm\*(Aq, \-value => \*(Aqmode2\*(Aq);
\&        $output .= $q\->submit();
\&        $output .= $q\->end_form();
\&        $output .= $q\->end_html();
\&
\&        return $output;
\&   }
\&
\&   sub showlist {
\&        my $self = shift;
\&
\&        # Get our database connection
\&        my $dbh = $self\->dbh();
\&
\&        # Get CGI query object
\&        my $q = $self\->query();
\&        my $widgetcode = $q\->param("widgetcode");
\&
\&        my $output = \*(Aq\*(Aq;
\&        $output .= $q\->start_html(\-title => \*(AqList of Matching Widgets\*(Aq);
\&
\&        ## Do a bunch of stuff to select "widgets" from a DBI\-connected
\&        ## database which match the user\-supplied value of "widgetcode"
\&        ## which has been supplied from the previous HTML form via a
\&        ## CGI.pm query object.
\&        ##
\&        ## Each row will contain a link to a "Widget Detail" which
\&        ## provides an anchor tag, as follows:
\&        ##
\&        ##   "widgetview.cgi?rm=mode3&widgetid=XXX"
\&        ##
\&        ##  ...Where "XXX" is a unique value referencing the ID of
\&        ## the particular "widget" upon which the user has clicked.
\&
\&        $output .= $q\->end_html();
\&
\&        return $output;
\&   }
\&
\&   sub showdetail {
\&        my $self = shift;
\&
\&        # Get our database connection
\&        my $dbh = $self\->dbh();
\&
\&        # Get CGI query object
\&        my $q = $self\->query();
\&        my $widgetid = $q\->param("widgetid");
\&
\&        my $output = \*(Aq\*(Aq;
\&        $output .= $q\->start_html(\-title => \*(AqWidget Detail\*(Aq);
\&
\&        ## Do a bunch of things to select all the properties of
\&        ## the particular "widget" upon which the user has
\&        ## clicked.  The key id value of this widget is provided
\&        ## via the "widgetid" property, accessed via the CGI.pm
\&        ## query object.
\&
\&        $output .= $q\->end_html();
\&
\&        return $output;
\&   }
\&
\&   1;  # Perl requires this at the end of all modules
.Ve
.PP
CGI::Application takes care of implementing the \fInew()\fR and the \fIrun()\fR
methods.  Notice that at no point do you call \fIprint()\fR to send any
output to \s-1STDOUT\s0.  Instead, all output is returned as a scalar.
.PP
CGI::Application's most significant contribution is in managing
the application state.  Notice that all which is needed to push
the application forward is to set the value of a \s-1HTML\s0 form
parameter 'rm' to the value of the \*(L"run mode\*(R" you wish to handle
the form submission.  This is the key to CGI::Application.
.SH "ABSTRACT"
.IX Header "ABSTRACT"
The guiding philosophy behind CGI::Application is that a web-based
application can be organized into a specific set of \*(L"Run Modes.\*(R"
Each Run Mode is roughly analogous to a single screen (a form, some
output, etc.).  All the Run Modes are managed by a single \*(L"Application
Module\*(R" which is a Perl module.  In your web server's document space
there is an \*(L"Instance Script\*(R" which is called by the web server as a
\&\s-1CGI\s0 (or an Apache::Registry script if you're using Apache + mod_perl).
.PP
This methodology is an inversion of the \*(L"Embedded\*(R" philosophy (\s-1ASP\s0, \s-1JSP\s0,
EmbPerl, Mason, etc.) in which there are \*(L"pages\*(R" for each state of the
application, and the page drives functionality.  In CGI::Application,
form follows function \*(-- the Application Module drives pages, and the
code for a single application is in one place; not spread out over
multiple \*(L"pages\*(R".  If you feel that Embedded architectures are
confusing, unorganized, difficult to design and difficult to manage,
CGI::Application is the methodology for you!
.PP
Apache is \s-1NOT\s0 a requirement for CGI::Application.  Web applications based on
CGI::Application will run equally well on \s-1NT/IIS\s0 or any other
CGI-compatible environment.  CGI::Application\-based projects
are, however, ripe for use on Apache/mod_perl servers, as they
naturally encourage Good Programming Practices and will often work
in persistent environments without modification.
.PP
For more information on using CGI::Application with mod_perl, please see our
website at http://www.cgi\-app.org/, as well as
CGI::Application::Plugin::Apache, which integrates with Apache::Request.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
It is intended that your Application Module will be implemented as a sub-class
of CGI::Application. This is done simply as follows:
.PP
.Vb 2
\&    package My::App; 
\&    use base \*(AqCGI::Application\*(Aq;
.Ve
.PP
\&\fBNotation and Conventions\fR
.PP
For the purpose of this document, we will refer to the
following conventions:
.PP
.Vb 6
\&  WebApp.pm   The Perl module which implements your Application Module class.
\&  WebApp      Your Application Module class; a sub\-class of CGI::Application.
\&  webapp.cgi  The Instance Script which implements your Application Module.
\&  $webapp     An instance (object) of your Application Module class.
\&  $c          Same as $webapp, used in instance methods to pass around the
\&              current object. (Sometimes referred as "$self" in other code)
.Ve
.SS "Instance Script Methods"
.IX Subsection "Instance Script Methods"
By inheriting from CGI::Application you have access to a
number of built-in methods.  The following are those which
are expected to be called from your Instance Script.
.PP
\fI\fInew()\fI\fR
.IX Subsection "new()"
.PP
The \fInew()\fR method is the constructor for a CGI::Application.  It returns
a blessed reference to your Application Module package (class).  Optionally,
\&\fInew()\fR may take a set of parameters as key => value pairs:
.PP
.Vb 7
\&    my $webapp = WebApp\->new(
\&                TMPL_PATH => \*(AqApp/\*(Aq,
\&                PARAMS => {
\&                        \*(Aqcustom_thing_1\*(Aq => \*(Aqsome val\*(Aq,
\&                        \*(Aqanother_custom_thing\*(Aq => [qw/123 456/]
\&                }
\&    );
.Ve
.PP
This method may take some specific parameters:
.PP
\&\fB\s-1TMPL_PATH\s0\fR \- This optional parameter defines a path to a directory of templates.
This is used by the \fIload_tmpl()\fR method (specified below), and may also be used
for the same purpose by other template plugins.  This run-time parameter allows
you to further encapsulate instantiating templates, providing potential for
more re-usability.  It can be either a scalar or an array reference of multiple
paths.
.PP
\&\fB\s-1QUERY\s0\fR \- This optional parameter allows you to specify an
already-created \s-1CGI\s0.pm query object.  Under normal use,
CGI::Application will instantiate its own \s-1CGI\s0.pm query object.
Under certain conditions, it might be useful to be able to use
one which has already been created.
.PP
\&\fB\s-1PARAMS\s0\fR \- This parameter, if used, allows you to set a number
of custom parameters at run-time.  By passing in different
values in different instance scripts which use the same application
module you can achieve a higher level of re-usability.  For instance,
imagine an application module, \*(L"Mailform.pm\*(R".  The application takes
the contents of a \s-1HTML\s0 form and emails it to a specified recipient.
You could have multiple instance scripts throughout your site which
all use this \*(L"Mailform.pm\*(R" module, but which set different recipients
or different forms.
.PP
One common use of instance scripts is to provide a path to a config file.  This
design allows you to define project wide configuration objects used by many
several instance scripts. There are several plugins which simplify the syntax
for this and provide lazy loading. Here's an example using
CGI::Application::Plugin::ConfigAuto, which uses Config::Auto to support
many configuration file formats.
.PP
.Vb 1
\& my $app = WebApp\->new(PARAMS => { cfg_file => \*(Aqconfig.pl\*(Aq });
\&
\& # Later in your app:
\& my %cfg = $self\->cfg()
\& # or ... $self\->cfg(\*(AqHTML_ROOT_DIR\*(Aq);
.Ve
.PP
See the list of of plugins below for more config file integration solutions.
.PP
\fI\fIrun()\fI\fR
.IX Subsection "run()"
.PP
The \fIrun()\fR method is called upon your Application Module object, from
your Instance Script.  When called, it executes the functionality
in your Application Module.
.PP
.Vb 2
\&    my $webapp = WebApp\->new();
\&    $webapp\->run();
.Ve
.PP
This method first determines the application state by looking at the
value of the \s-1CGI\s0 parameter specified by \fImode_param()\fR (defaults to
\&'rm' for \*(L"Run Mode\*(R"), which is expected to contain the name of the mode of
operation.  If not specified, the state defaults to the value
of \fIstart_mode()\fR.
.PP
Once the mode has been determined, \fIrun()\fR looks at the dispatch
table stored in \fIrun_modes()\fR and finds the function pointer which
is keyed from the mode name.  If found, the function is called and the
data returned is \fIprint()\fR'ed to \s-1STDOUT\s0 and to the browser.  If
the specified mode is not found in the \fIrun_modes()\fR table, \fIrun()\fR will
\&\fIcroak()\fR.
.SS "\s-1PSGI\s0 support"
.IX Subsection "PSGI support"
CGI::Application offers native \s-1PSGI\s0 support. The default query object
for this is \s-1CGI::PSGI\s0, which simply wrappers \s-1CGI\s0.pm to provide \s-1PSGI\s0
support to it.
.PP
\fI\fIpsgi_app()\fI\fR
.IX Subsection "psgi_app()"
.PP
.Vb 1
\& $psgi_coderef = WebApp\->psgi_app({ ... args to new() ... });
.Ve
.PP
The simplest way to create and return a PSGI-compatible coderef. Pass in
arguments to a hashref just as would to new. This returns a PSGI-compatible
coderef, using \s-1CGI:::PSGI\s0 as the query object. To use a different query
object, construct your own object using \f(CW\*(C`run_as_psgi()\*(C'\fR, as shown below.
.PP
It's possible that we'll change from \s-1CGI::PSGI\s0 to a different-but-compatible
query object for \s-1PSGI\s0 support in the future, perhaps if \s-1CGI\s0.pm adds native
\&\s-1PSGI\s0 support.
.PP
\fI\fIrun_as_psgi()\fI\fR
.IX Subsection "run_as_psgi()"
.PP
.Vb 1
\& my $psgi_aref = $webapp\->run_as_psgi;
.Ve
.PP
Just like \f(CW\*(C`run\*(C'\fR, but prints no output and returns the data structure
required by the \s-1PSGI\s0 specification. Use this if you want to run the
application on top of a PSGI-compatible handler, such as Plack provides.
.PP
If you are just getting started, just use \f(CW\*(C`run()\*(C'\fR. It's easy to switch to using
\&\f(CW\*(C`run_as_psgi\*(C'\fR later.
.PP
Why use \f(CW\*(C`run_as_psgi()\*(C'\fR? There are already solutions to run
CGI::Application\-based projects on several web servers with dozens of plugins.
Running as a PSGI-compatible application provides the ability to run on
additional PSGI-compatible servers, as well as providing access to all of the
\&\*(L"Middleware\*(R" solutions available through the Plack project.
.PP
The structure returned is an arrayref, containing the status code, an arrayref
of header key/values and an arrayref containing the body.
.PP
.Vb 1
\& [ 200, [ \*(AqContent\-Type\*(Aq => \*(Aqtext/html\*(Aq ], [ $body ] ]
.Ve
.PP
By default the body is a single scalar, but plugins may modify this to return
other value \s-1PSGI\s0 values.  See \*(L"The Response\*(R" in \s-1PSGI\s0 for details about the
response format.
.PP
Note that calling \f(CW\*(C`run_as_psgi\*(C'\fR only handles the \fIoutput\fR portion of the
\&\s-1PSGI\s0 spec. to handle the input, you need to use a \s-1CGI\s0.pm\-like query object that
is PSGI-compliant, such as \s-1CGI::PSGI\s0. This query object must provide psgi_header
and psgi_redirect methods.
.PP
The final result might look like this:
.PP
.Vb 2
\&    use WebApp;
\&    use CGI::PSGI;
\&
\&    my $handler = sub {
\&        my $env = shift;
\&        my $webapp = WebApp\->new({ QUERY => CGI::PSGI\->new($env) });
\&        $webapp\->run_as_psgi;
\&    };
.Ve
.SS "Methods to possibly override"
.IX Subsection "Methods to possibly override"
CGI::Application implements some methods which are expected to be overridden
by implementing them in your sub-class module.  These methods are as follows:
.PP
\fI\fIsetup()\fI\fR
.IX Subsection "setup()"
.PP
This method is called by the inherited \fInew()\fR constructor method.  The
\&\fIsetup()\fR method should be used to define the following property/methods:
.PP
.Vb 5
\&    mode_param() \- set the name of the run mode CGI param.
\&    start_mode() \- text scalar containing the default run mode.
\&    error_mode() \- text scalar containing the error mode.
\&    run_modes() \- hash table containing mode => function mappings.
\&    tmpl_path() \- text scalar or array reference containing path(s) to template files.
.Ve
.PP
Your \fIsetup()\fR method may call any of the instance methods of your application.
This function is a good place to define properties specific to your application
via the \f(CW$webapp\fR\->\fIparam()\fR method.
.PP
Your \fIsetup()\fR method might be implemented something like this:
.PP
.Vb 10
\&        sub setup {
\&                my $self = shift;
\&                $self\->tmpl_path(\*(Aq/path/to/my/templates/\*(Aq);
\&                $self\->start_mode(\*(Aqputform\*(Aq);
\&                $self\->error_mode(\*(Aqmy_error_rm\*(Aq);
\&                $self\->run_modes({
\&                        \*(Aqputform\*(Aq  => \*(Aqmy_putform_func\*(Aq,
\&                        \*(Aqpostdata\*(Aq => \*(Aqmy_data_func\*(Aq
\&                });
\&                $self\->param(\*(Aqmyprop1\*(Aq);
\&                $self\->param(\*(Aqmyprop2\*(Aq, \*(Aqprop2value\*(Aq);
\&                $self\->param(\*(Aqmyprop3\*(Aq, [\*(Aqp3v1\*(Aq, \*(Aqp3v2\*(Aq, \*(Aqp3v3\*(Aq]);
\&        }
.Ve
.PP
However, often times all that needs to be in \fIsetup()\fR is defining your run modes
and your start mode. CGI::Application::Plugin::AutoRunmode allows you to do  
this with a simple syntax, using run mode attributes:
.PP
.Vb 1
\& use CGI::Application::Plugin::AutoRunmode;
\&
\& sub show_first : StartRunmode { ... };
\& sub do_next : Runmode { ... }
.Ve
.PP
\fI\fIteardown()\fI\fR
.IX Subsection "teardown()"
.PP
If implemented, this method is called automatically after your application runs.  It
can be used to clean up after your operations.  A typical use of the
\&\fIteardown()\fR function is to disconnect a database connection which was
established in the \fIsetup()\fR function.  You could also use the \fIteardown()\fR
method to store state information about the application to the server.
.PP
\fI\fIcgiapp_init()\fI\fR
.IX Subsection "cgiapp_init()"
.PP
If implemented, this method is called automatically right before the
\&\fIsetup()\fR method is called.  This method provides an optional initialization
hook, which improves the object-oriented characteristics of
CGI::Application.  The \fIcgiapp_init()\fR method receives, as its parameters,
all the arguments which were sent to the \fInew()\fR method.
.PP
An example of the benefits provided by utilizing this hook is
creating a custom \*(L"application super-class\*(R" from which all
your web applications would inherit, instead of CGI::Application.
.PP
Consider the following:
.PP
.Vb 8
\&  # In MySuperclass.pm:
\&  package MySuperclass;
\&  use base \*(AqCGI::Application\*(Aq;
\&  sub cgiapp_init {
\&        my $self = shift;
\&        # Perform some project\-specific init behavior
\&        # such as to load settings from a database or file.
\&  }
\&
\&
\&  # In MyApplication.pm:
\&  package MyApplication;
\&  use base \*(AqMySuperclass\*(Aq;
\&  sub setup { ... }
\&  sub teardown { ... }
\&  # The rest of your CGI::Application\-based follows...
.Ve
.PP
By using CGI::Application and the \fIcgiapp_init()\fR method as illustrated,
a suite of applications could be designed to share certain
characteristics.  This has the potential for much cleaner code
built on object-oriented inheritance.
.PP
\fI\fIcgiapp_prerun()\fI\fR
.IX Subsection "cgiapp_prerun()"
.PP
If implemented, this method is called automatically right before the
selected run mode method is called.  This method provides an optional
pre-runmode hook, which permits functionality to be added at the point
right before the run mode method is called.  To further leverage this
hook, the value of the run mode is passed into \fIcgiapp_prerun()\fR.
.PP
Another benefit provided by utilizing this hook is
creating a custom \*(L"application super-class\*(R" from which all
your web applications would inherit, instead of CGI::Application.
.PP
Consider the following:
.PP
.Vb 9
\&  # In MySuperclass.pm:
\&  package MySuperclass;
\&  use base \*(AqCGI::Application\*(Aq;
\&  sub cgiapp_prerun {
\&        my $self = shift;
\&        # Perform some project\-specific init behavior
\&        # such as to implement run mode specific
\&        # authorization functions.
\&  }
\&
\&
\&  # In MyApplication.pm:
\&  package MyApplication;
\&  use base \*(AqMySuperclass\*(Aq;
\&  sub setup { ... }
\&  sub teardown { ... }
\&  # The rest of your CGI::Application\-based follows...
.Ve
.PP
By using CGI::Application and the \fIcgiapp_prerun()\fR method as illustrated,
a suite of applications could be designed to share certain
characteristics.  This has the potential for much cleaner code
built on object-oriented inheritance.
.PP
It is also possible, within your \fIcgiapp_prerun()\fR method, to change the
run mode of your application.  This can be done via the \fIprerun_mode()\fR
method, which is discussed elsewhere in this \s-1POD\s0.
.PP
\fI\fIcgiapp_postrun()\fI\fR
.IX Subsection "cgiapp_postrun()"
.PP
If implemented, this hook will be called after the run mode method
has returned its output, but before \s-1HTTP\s0 headers are generated.  This
will give you an opportunity to modify the body and headers before they
are returned to the web browser.
.PP
A typical use for this hook is pipelining the output of a CGI-Application
through a series of \*(L"filter\*(R" processors.  For example:
.PP
.Vb 2
\&  * You want to enclose the output of all your CGI\-Applications in
\&    an HTML table in a larger page.
\&
\&  * Your run modes return structured data (such as XML), which you
\&    want to transform using a standard mechanism (such as XSLT).
\&
\&  * You want to post\-process CGI\-App output through another system,
\&    such as HTML::Mason.
\&
\&  * You want to modify HTTP headers in a particular way across all
\&    run modes, based on particular criteria.
.Ve
.PP
The \fIcgiapp_postrun()\fR hook receives a reference to the output from
your run mode method, in addition to the CGI-App object.  A typical
\&\fIcgiapp_postrun()\fR method might be implemented as follows:
.PP
.Vb 3
\&  sub cgiapp_postrun {
\&    my $self = shift;
\&    my $output_ref = shift;
\&
\&    # Enclose output HTML table
\&    my $new_output = "<table border=1>";
\&    $new_output .= "<tr><td> Hello, World! </td></tr>";
\&    $new_output .= "<tr><td>". $$output_ref ."</td></tr>";
\&    $new_output .= "</table>";
\&
\&    # Replace old output with new output
\&    $$output_ref = $new_output;
\&  }
.Ve
.PP
Obviously, with access to the CGI-App object you have full access to use all
the methods normally available in a run mode.  You could, for example, use
\&\f(CW\*(C`load_tmpl()\*(C'\fR to replace the static \s-1HTML\s0 in this example with HTML::Template.
You could change the \s-1HTTP\s0 headers (via \f(CW\*(C`header_type()\*(C'\fR and \f(CW\*(C`header_props()\*(C'\fR
methods) to set up a redirect.  You could also use the objects properties
to apply changes only under certain circumstance, such as a in only certain run
modes, and when a \f(CW\*(C`param()\*(C'\fR is a particular value.
.PP
\fI\fIcgiapp_get_query()\fI\fR
.IX Subsection "cgiapp_get_query()"
.PP
.Vb 1
\& my $q = $webapp\->cgiapp_get_query;
.Ve
.PP
Override this method to retrieve the query object if you wish to use a
different query interface instead of \s-1CGI\s0.pm.
.PP
\&\s-1CGI\s0.pm is only loaded if it is used on a given request.
.PP
If you can use an alternative to \s-1CGI\s0.pm, it needs to have some compatibility
with the \s-1CGI\s0.pm \s-1API\s0. For normal use, just having a compatible \f(CW\*(C`param\*(C'\fR method
should be sufficient.
.PP
If you use the \f(CW\*(C`path_info\*(C'\fR option to the \fImode_param()\fR method, then we will call
the \f(CW\*(C`path_info()\*(C'\fR method on the query object.
.PP
If you use the \f(CW\*(C`Dump\*(C'\fR method in CGI::Application, we will call the \f(CW\*(C`Dump\*(C'\fR and
\&\f(CW\*(C`escapeHTML\*(C'\fR methods on the query object.
.SS "Essential Application Methods"
.IX Subsection "Essential Application Methods"
The following methods are inherited from CGI::Application, and are
available to be called by your application within your Application
Module. They are called essential because you will use all are most
of them to get any application up and running.  These functions are listed in alphabetical order.
.PP
\fI\fIload_tmpl()\fI\fR
.IX Subsection "load_tmpl()"
.PP
.Vb 4
\&    my $tmpl_obj = $webapp\->load_tmpl;
\&    my $tmpl_obj = $webapp\->load_tmpl(\*(Aqsome.html\*(Aq);
\&    my $tmpl_obj = $webapp\->load_tmpl( \e$template_content );
\&    my $tmpl_obj = $webapp\->load_tmpl( FILEHANDLE );
.Ve
.PP
This method takes the name of a template file, a reference to template data
or a \s-1FILEHANDLE\s0 and returns an HTML::Template object. If the filename is undefined or missing, CGI::Application will default to trying to use the current run mode name, plus the extension \*(L".html\*(R".
.PP
If you use the default template naming system, you should also use
CGI::Application::Plugin::Forward, which simply helps to keep the current
name accurate when you pass control from one run mode to another.
.PP
( For integration with other template systems
and automated template names, see "Alternatives to \fIload_tmpl()\fR below. )
.PP
When you pass in a filename, the HTML::Template\->\fInew_file()\fR constructor
is used for create the object.  When you pass in a reference to the template
content, the HTML::Template\->\fInew_scalar_ref()\fR constructor is used and
when you pass in a filehandle, the HTML::Template\->\fInew_filehandle()\fR
constructor is used.
.PP
Refer to HTML::Template for specific usage of HTML::Template.
.PP
If \fItmpl_path()\fR has been specified, \fIload_tmpl()\fR will set the
HTML::Template \f(CW\*(C`path\*(C'\fR option to the path(s) provided.  This further
assists in encapsulating template usage.
.PP
The \fIload_tmpl()\fR method will pass any extra parameters sent to it directly to
HTML::Template\->\fInew_file()\fR (or \fInew_scalar_ref()\fR or \fInew_filehandle()\fR).
This will allow the HTML::Template object to be further customized:
.PP
.Vb 4
\&    my $tmpl_obj = $webapp\->load_tmpl(\*(Aqsome_other.html\*(Aq,
\&         die_on_bad_params => 0,
\&         cache => 1
\&    );
.Ve
.PP
Note that if you want to pass extra arguments but use the default template
name, you still need to provide a name of \f(CW\*(C`undef\*(C'\fR:
.PP
.Vb 4
\&    my $tmpl_obj = $webapp\->load_tmpl(undef,
\&         die_on_bad_params => 0,
\&         cache => 1
\&    );
.Ve
.PP
\&\fBAlternatives to \f(BIload_tmpl()\fB\fR
.PP
If your application requires more specialized behavior than this, you can
always replace it by overriding \fIload_tmpl()\fR by implementing your own
\&\fIload_tmpl()\fR in your CGI::Application sub-class application module.
.PP
First, you may want to check out the template related plugins.
.PP
CGI::Application::Plugin::TT focuses just on Template Toolkit integration,
and features pre-and-post features, singleton support and more.
.PP
CGI::Application::Plugin::Stream can help if you want to return a stream and
not a file. It features a simple syntax and MIME-type detection.
.PP
\&\fBspecifying the template class with \f(BIhtml_tmpl_class()\fB\fR
.PP
You may specify an API-compatible alternative to HTML::Template by setting
a new \f(CW\*(C`html_tmpl_class()\*(C'\fR:
.PP
.Vb 1
\&  $self\->html_tmpl_class(\*(AqHTML::Template::Dumper\*(Aq);
.Ve
.PP
The default is \*(L"HTML::Template\*(R". The alternate class should
provide at least the following parts of the HTML::Template \s-1API:\s0
.PP
.Vb 4
\& $t = $class\->new( scalarref => ... );  # If you use scalarref templates
\& $t = $class\->new( filehandle => ... ); # If you use filehandle templates
\& $t = $class\->new( filename => ... );
\& $t\->param(...);
.Ve
.PP
Here's an example case allowing you to precisely test what's sent to your
templates:
.PP
.Vb 5
\&    $ENV{CGI_APP_RETURN_ONLY} = 1;
\&    my $webapp = WebApp\->new;
\&       $webapp\->html_tmpl_class(\*(AqHTML::Template::Dumper\*(Aq); 
\&    my $out_str = $webapp\->run;
\&    my $tmpl_href = eval "$out_str";
\&
\&    # Now Precisely test what would be set to the template
\&    is ($tmpl_href\->{pet_name}, \*(AqDaisy\*(Aq, "Daisy is sent template");
.Ve
.PP
This is a powerful technique because HTML::Template::Dumper loads and considers
the template file that would actually be used. If the 'pet_name' token was missing
in the template, the above test would fail. So, you are testing both your code
and your templates in a much more precise way than using simple regular
expressions to see if the string \*(L"Daisy\*(R" appeared somewhere on the page.
.PP
\&\fBThe \f(BIload_tmpl()\fB callback\fR
.PP
Plugin authors will be interested to know that you can register a callback that
will be executed just before \fIload_tmpl()\fR returns:
.PP
.Vb 1
\&  $self\->add_callback(\*(Aqload_tmpl\*(Aq,\e&your_method);
.Ve
.PP
When \f(CW\*(C`your_method()\*(C'\fR is executed, it will be passed three arguments:
.PP
.Vb 6
\& 1. A hash reference of the extra params passed into C<load_tmpl>
\& 2. Followed by a hash reference to template parameters. 
\&    With both of these, you can modify them by reference to affect 
\&    values that are actually passed to the new() and param() methods of the
\&    template object.
\& 3. The name of the template file.
.Ve
.PP
Here's an example stub for a \fIload_tmpl()\fR callback:
.PP
.Vb 4
\&    sub my_load_tmpl_callback {
\&        my ($c, $ht_params, $tmpl_params, $tmpl_file) = @_
\&        # modify $ht_params or $tmpl_params by reference...    
\&    }
.Ve
.PP
\fI\fIparam()\fI\fR
.IX Subsection "param()"
.PP
.Vb 1
\&    $webapp\->param(\*(Aqpname\*(Aq, $somevalue);
.Ve
.PP
The \fIparam()\fR method provides a facility through which you may set
application instance properties which are accessible throughout
your application.
.PP
The \fIparam()\fR method may be used in two basic ways.  First, you may use it
to get or set the value of a parameter:
.PP
.Vb 2
\&    $webapp\->param(\*(Aqscalar_param\*(Aq, \*(Aq123\*(Aq);
\&    my $scalar_param_values = $webapp\->param(\*(Aqsome_param\*(Aq);
.Ve
.PP
Second, when called in the context of an array, with no parameter name
specified, \fIparam()\fR returns an array containing all the parameters which
currently exist:
.PP
.Vb 1
\&    my @all_params = $webapp\->param();
.Ve
.PP
The \fIparam()\fR method also allows you to set a bunch of parameters at once
by passing in a hash (or hashref):
.PP
.Vb 5
\&    $webapp\->param(
\&        \*(Aqkey1\*(Aq => \*(Aqval1\*(Aq,
\&        \*(Aqkey2\*(Aq => \*(Aqval2\*(Aq,
\&        \*(Aqkey3\*(Aq => \*(Aqval3\*(Aq,
\&    );
.Ve
.PP
The \fIparam()\fR method enables a very valuable system for
customizing your applications on a per-instance basis.
One Application Module might be instantiated by different
Instance Scripts.  Each Instance Script might set different values for a
set of parameters.  This allows similar applications to share a common
code-base, but behave differently.  For example, imagine a mail form
application with a single Application Module, but multiple Instance
Scripts.  Each Instance Script might specify a different recipient.
Another example would be a web bulletin boards system.  There could be
multiple boards, each with a different topic and set of administrators.
.PP
The \fInew()\fR method provides a shortcut for specifying a number of run-time
parameters at once.  Internally, CGI::Application calls the \fIparam()\fR
method to set these properties.  The \fIparam()\fR method is a powerful tool for
greatly increasing your application's re-usability.
.PP
\fI\fIquery()\fI\fR
.IX Subsection "query()"
.PP
.Vb 2
\&    my $q = $webapp\->query();
\&    my $remote_user = $q\->remote_user();
.Ve
.PP
This method retrieves the \s-1CGI\s0.pm query object which has been created
by instantiating your Application Module.  For details on usage of this
query object, refer to \s-1CGI\s0.  CGI::Application is built on the \s-1CGI\s0
module.  Generally speaking, you will want to become very familiar
with \s-1CGI\s0.pm, as you will use the query object whenever you want to
interact with form data.
.PP
When the \fInew()\fR method is called, a \s-1CGI\s0 query object is automatically created.
If, for some reason, you want to use your own \s-1CGI\s0 query object, the \fInew()\fR
method supports passing in your existing query object on construction using
the \s-1QUERY\s0 attribute.
.PP
There are a few rare situations where you want your own query object to be 
used after your Application Module has already been constructed. In that case 
you can pass it to c<\fIquery()\fR> like this:
.PP
.Vb 2
\&    $webapp\->query($new_query_object);
\&    my $q = $webapp\->query(); # now uses $new_query_object
.Ve
.PP
\fI\fIrun_modes()\fI\fR
.IX Subsection "run_modes()"
.PP
.Vb 5
\&    # The common usage: an arrayref of run mode names that exactly match subroutine names
\&    $webapp\->run_modes([qw/
\&        form_display
\&        form_process
\&    /]);
\&
\&   # With a hashref, use a different name or a code ref
\&   $webapp\->run_modes(
\&           \*(Aqmode1\*(Aq => \*(Aqsome_sub_by_name\*(Aq, 
\&           \*(Aqmode2\*(Aq => \e&some_other_sub_by_ref
\&    );
.Ve
.PP
This accessor/mutator specifies the dispatch table for the
application states, using the syntax examples above. It returns 
the dispatch table as a hash.
.PP
The \fIrun_modes()\fR method may be called more than once.  Additional values passed
into \fIrun_modes()\fR will be added to the run modes table.  In the case that an
existing run mode is re-defined, the new value will override the existing value.
This behavior might be useful for applications which are created via inheritance
from another application, or some advanced application which modifies its
own capabilities based on user input.
.PP
The \fIrun()\fR method uses the data in this table to send the application to the
correct function as determined by reading the \s-1CGI\s0 parameter specified by
\&\fImode_param()\fR (defaults to 'rm' for \*(L"Run Mode\*(R").  These functions are referred
to as \*(L"run mode methods\*(R".
.PP
The hash table set by this method is expected to contain the mode
name as a key.  The value should be either a hard reference (a subref)
to the run mode method which you want to be called when the application enters
the specified run mode, or the name of the run mode method to be called:
.PP
.Vb 2
\&    \*(Aqmode_name_by_ref\*(Aq  => \e&mode_function
\&    \*(Aqmode_name_by_name\*(Aq => \*(Aqmode_function\*(Aq
.Ve
.PP
The run mode method specified is expected to return a block of text (e.g.:
\&\s-1HTML\s0) which will eventually be sent back to the web browser.  The run mode
method may return its block of text as a scalar or a scalar-ref.
.PP
An advantage of specifying your run mode methods by name instead of
by reference is that you can more easily create derivative applications
using inheritance.  For instance, if you have a new application which is
exactly the same as an existing application with the exception of one
run mode, you could simply inherit from that other application and override
the run mode method which is different.  If you specified your run mode
method by reference, your child class would still use the function
from the parent class.
.PP
An advantage of specifying your run mode methods by reference instead of by name
is performance.  Dereferencing a subref is faster than \fIeval()\fR\-ing
a code block.  If run-time performance is a critical issue, specify
your run mode methods by reference and not by name.  The speed differences
are generally small, however, so specifying by name is preferred.
.PP
Specifying the run modes by array reference:
.PP
.Vb 1
\&    $webapp\->run_modes([ \*(Aqmode1\*(Aq, \*(Aqmode2\*(Aq, \*(Aqmode3\*(Aq ]);
.Ve
.PP
Is is the same as using a hash, with keys equal to values
.PP
.Vb 5
\&    $webapp\->run_modes(
\&        \*(Aqmode1\*(Aq => \*(Aqmode1\*(Aq,
\&        \*(Aqmode2\*(Aq => \*(Aqmode2\*(Aq,
\&        \*(Aqmode3\*(Aq => \*(Aqmode3\*(Aq
\&    );
.Ve
.PP
Often, it makes good organizational sense to have your run modes map to
methods of the same name.  The array-ref interface provides a shortcut
to that behavior while reducing verbosity of your code.
.PP
Note that another importance of specifying your run modes in either a
hash or array-ref is to assure that only those Perl methods which are
specifically designated may be called via your application.  Application
environments which don't specify allowed methods and disallow all others
are insecure, potentially opening the door to allowing execution of
arbitrary code.  CGI::Application maintains a strict \*(L"default-deny\*(R" stance
on all method invocation, thereby allowing secure applications
to be built upon it.
.PP
\&\fB\s-1IMPORTANT\s0 \s-1NOTE\s0 \s-1ABOUT\s0 \s-1RUN\s0 \s-1MODE\s0 \s-1METHODS\s0\fR
.PP
Your application should *NEVER* \fIprint()\fR to \s-1STDOUT\s0.
Using \fIprint()\fR to send output to \s-1STDOUT\s0 (including \s-1HTTP\s0 headers) is
exclusively the domain of the inherited \fIrun()\fR method.  Breaking this
rule is a common source of errors.  If your program is erroneously
sending content before your \s-1HTTP\s0 header, you are probably breaking this rule.
.PP
\&\fB\s-1THE\s0 \s-1RUN\s0 \s-1MODE\s0 \s-1OF\s0 \s-1LAST\s0 \s-1RESORT:\s0 \*(L"\s-1AUTOLOAD\s0\*(R"\fR
.PP
If CGI::Application is asked to go to a run mode which doesn't exist
it will usually \fIcroak()\fR with errors.  If this is not your desired
behavior, it is possible to catch this exception by implementing
a run mode with the reserved name \*(L"\s-1AUTOLOAD\s0\*(R":
.PP
.Vb 3
\&  $self\->run_modes(
\&        "AUTOLOAD" => \e&catch_my_exception
\&  );
.Ve
.PP
Before CGI::Application calls \fIcroak()\fR it will check for the existence
of a run mode called \*(L"\s-1AUTOLOAD\s0\*(R".  If specified, this run mode will in
invoked just like a regular run mode, with one exception:  It will
receive, as an argument, the name of the run mode which invoked it:
.PP
.Vb 3
\&  sub catch_my_exception {
\&        my $self = shift;
\&        my $intended_runmode = shift;
\&
\&        my $output = "Looking for \*(Aq$intended_runmode\*(Aq, but found \*(AqAUTOLOAD\*(Aq instead";
\&        return $output;
\&  }
.Ve
.PP
This functionality could be used for a simple human-readable error
screen, or for more sophisticated application behaviors.
.PP
\fI\fIstart_mode()\fI\fR
.IX Subsection "start_mode()"
.PP
.Vb 1
\&    $webapp\->start_mode(\*(Aqmode1\*(Aq);
.Ve
.PP
The start_mode contains the name of the mode as specified in the \fIrun_modes()\fR
table.  Default mode is \*(L"start\*(R".  The mode key specified here will be used
whenever the value of the \s-1CGI\s0 form parameter specified by \fImode_param()\fR is
not defined.  Generally, this is the first time your application is executed.
.PP
\fI\fItmpl_path()\fI\fR
.IX Subsection "tmpl_path()"
.PP
.Vb 1
\&    $webapp\->tmpl_path(\*(Aq/path/to/some/templates/\*(Aq);
.Ve
.PP
This access/mutator method sets the file path to the directory (or directories)
where the templates are stored.  It is used by \fIload_tmpl()\fR to find the template
files, using HTML::Template's \f(CW\*(C`path\*(C'\fR option. To set the path you can either
pass in a text scalar or an array reference of multiple paths.
.SS "More Application Methods"
.IX Subsection "More Application Methods"
You can skip this section if you are just getting started.
.PP
The following additional methods are inherited from CGI::Application, and are
available to be called by your application within your Application Module.
These functions are listed in alphabetical order.
.PP
\fI\fIdelete()\fI\fR
.IX Subsection "delete()"
.PP
.Vb 1
\&    $webapp\->delete(\*(Aqmy_param\*(Aq);
.Ve
.PP
The \fIdelete()\fR method is used to delete a parameter that was previously
stored inside of your application either by using the \s-1PARAMS\s0 hash that
was passed in your call to \fInew()\fR or by a call to the \fIparam()\fR method.
This is similar to the \fIdelete()\fR method of \s-1CGI\s0.pm. It is useful if your
application makes decisions based on the existence of certain params that
may have been removed in previous sections of your app or simply to
clean-up your \fIparam()\fRs.
.PP
\fI\fIdump()\fI\fR
.IX Subsection "dump()"
.PP
.Vb 1
\&    print STDERR $webapp\->dump();
.Ve
.PP
The \fIdump()\fR method is a debugging function which will return a
chunk of text which contains all the environment and web form
data of the request, formatted nicely for human readability.
Useful for outputting to \s-1STDERR\s0.
.PP
\fI\fIdump_html()\fI\fR
.IX Subsection "dump_html()"
.PP
.Vb 1
\&    my $output = $webapp\->dump_html();
.Ve
.PP
The \fIdump_html()\fR method is a debugging function which will return
a chunk of text which contains all the environment and web form
data of the request, formatted nicely for human readability via
a web browser.  Useful for outputting to a browser.
.PP
\fI\fIerror_mode()\fI\fR
.IX Subsection "error_mode()"
.PP
.Vb 1
\&    $webapp\->error_mode(\*(Aqmy_error_rm\*(Aq);
.Ve
.PP
If the runmode dies for whatever reason, \f(CW\*(C`run() will\*(C'\fR see if you have set a
value for \f(CW\*(C`error_mode()\*(C'\fR. If you have, \f(CW\*(C`run()\*(C'\fR will call that method
as a run mode, passing $@ as the only parameter.
.PP
Plugins authors will be interested to know that just before \f(CW\*(C`error_mode()\*(C'\fR is
called, the \f(CW\*(C`error\*(C'\fR hook will be executed, with the error message passed in as
the only parameter.
.PP
No \f(CW\*(C`error_mode\*(C'\fR is defined by default.  The death of your \f(CW\*(C`error_mode()\*(C'\fR run
mode is not trapped, so you can also use it to die in your own special way.
.PP
For a complete integrated logging solution, check out CGI::Application::Plugin::LogDispatch.
.PP
\fI\fIget_current_runmode()\fI\fR
.IX Subsection "get_current_runmode()"
.PP
.Vb 1
\&    $webapp\->get_current_runmode();
.Ve
.PP
The \f(CW\*(C`get_current_runmode()\*(C'\fR method will return a text scalar containing
the name of the run mode which is currently being executed.  If the
run mode has not yet been determined, such as during \fIsetup()\fR, this method
will return undef.
.PP
\fI\fIheader_add()\fI\fR
.IX Subsection "header_add()"
.PP
.Vb 2
\&    # add or replace the \*(Aqtype\*(Aq header
\&    $webapp\->header_add( \-type => \*(Aqimage/png\*(Aq );
\&
\&    \- or \-
\&
\&    # add an additional cookie
\&    $webapp\->header_add(\-cookie=>[$extra_cookie]);
.Ve
.PP
The \f(CW\*(C`header_add()\*(C'\fR method is used to add one or more headers to the outgoing
response headers.  The parameters will eventually be passed on to the \s-1CGI\s0.pm
\&\fIheader()\fR method, so refer to the \s-1CGI\s0 docs for exact usage details.
.PP
Unlike calling \f(CW\*(C`header_props()\*(C'\fR, \f(CW\*(C`header_add()\*(C'\fR will preserve any existing
headers. If a scalar value is passed to \f(CW\*(C`header_add()\*(C'\fR it will replace
the existing value for that key.
.PP
If an array reference is passed as a value to \f(CW\*(C`header_add()\*(C'\fR, values in
that array ref will be appended to any existing values values for that key.
This is primarily useful for setting an additional cookie after one has already
been set.
.PP
\fI\fIheader_props()\fI\fR
.IX Subsection "header_props()"
.PP
.Vb 2
\&    # Set a complete set of headers
\&    %set_headers = $webapp\->header_props(\-type=>\*(Aqimage/gif\*(Aq,\-expires=>\*(Aq+3d\*(Aq);
\&
\&    # clobber / reset all headers
\&    %set_headers = $webapp\->header_props({});
\&
\&    # Just retrieve the headers 
\&    %set_headers = $webapp\->header_props();
.Ve
.PP
The \f(CW\*(C`header_props()\*(C'\fR method expects a hash of \s-1CGI\s0.pm\-compatible
\&\s-1HTTP\s0 header properties.  These properties will be passed directly
to the \f(CW\*(C`header()\*(C'\fR or \f(CW\*(C`redirect()\*(C'\fR methods of the \fIquery()\fR object. Refer
to the docs of your query object for details. (Be default, it's \s-1CGI\s0.pm).
.PP
Calling header_props with an empty hashref clobber any existing headers that have
previously set.
.PP
\&\f(CW\*(C`header_props()\*(C'\fR returns a hash of all the headers that have currently been
set. It can be called with no arguments just to get the hash current headers
back.
.PP
To add additional headers later without clobbering the old ones,
see \f(CW\*(C`header_add()\*(C'\fR.
.PP
\&\fB\s-1IMPORTANT\s0 \s-1NOTE\s0 \s-1REGARDING\s0 \s-1HTTP\s0 \s-1HEADERS\s0\fR
.PP
It is through the \f(CW\*(C`header_props()\*(C'\fR and \f(CW\*(C`header_add()\*(C'\fR method that you may modify the outgoing
\&\s-1HTTP\s0 headers.  This is necessary when you want to set a cookie, set the mime
type to something other than \*(L"text/html\*(R", or perform a redirect.  The
\&\fIheader_props()\fR method works in conjunction with the \fIheader_type()\fR method.
The value contained in \fIheader_type()\fR determines if we use \fICGI::header()\fR or
\&\fICGI::redirect()\fR.  The content of \fIheader_props()\fR is passed as an argument to
whichever \s-1CGI\s0.pm function is called.
.PP
Understanding this relationship is important if you wish to manipulate
the \s-1HTTP\s0 header properly.
.PP
\fI\fIheader_type()\fI\fR
.IX Subsection "header_type()"
.PP
.Vb 2
\&    $webapp\->header_type(\*(Aqredirect\*(Aq);
\&    $webapp\->header_type(\*(Aqnone\*(Aq);
.Ve
.PP
This method used to declare that you are setting a redirection header,
or that you want no header to be returned by the framework.
.PP
The value of 'header' is almost never used, as it is the default.
.PP
\&\fBExample of redirecting\fR:
.PP
.Vb 6
\&  sub some_redirect_mode {
\&    my $self = shift;
\&    # do stuff here.... 
\&    $self\->header_type(\*(Aqredirect\*(Aq);
\&    $self\->header_props(\-url=>  "http://site/path/doc.html" );
\&  }
.Ve
.PP
To simplify that further, use CGI::Application::Plugin::Redirect:
.PP
.Vb 1
\&    return $self\->redirect(\*(Aqhttp://www.example.com/\*(Aq);
.Ve
.PP
Setting the header to 'none' may be useful if you are streaming content.
In other contexts, it may be more useful to set \f(CW\*(C`$ENV{CGI_APP_RETURN_ONLY} = 1;\*(C'\fR,
which supresses all printing, including headers, and returns the output instead.
.PP
That's commonly used for testing, or when using CGI::Application as a controller
for a cron script!
.PP
\fI\fImode_param()\fI\fR
.IX Subsection "mode_param()"
.PP
.Vb 3
\& # Name the CGI form parameter that contains the run mode name.
\& # This is the the default behavior, and is often sufficient.
\& $webapp\->mode_param(\*(Aqrm\*(Aq);
\&
\& # Set the run mode name directly from a code ref
\& $webapp\->mode_param(\e&some_method);
\&
\& # Alternate interface, which allows you to set the run
\& # mode name directly from $ENV{PATH_INFO}.
\& $webapp\->mode_param(
\&        path_info=> 1,
\&        param =>\*(Aqrm\*(Aq
\& );
.Ve
.PP
This accessor/mutator method is generally called in the \fIsetup()\fR method.
It is used to help determine the run mode to call. There are three options for calling it.
.PP
.Vb 1
\& $webapp\->mode_param(\*(Aqrm\*(Aq);
.Ve
.PP
Here, a \s-1CGI\s0 form parameter is named that will contain the name of the run mode
to use. This is the default behavior, with 'rm' being the parameter named used.
.PP
.Vb 1
\& $webapp\->mode_param(\e&some_method);
.Ve
.PP
Here a code reference is provided. It will return the name of the run mode
to use directly. Example:
.PP
.Vb 4
\& sub some_method {
\&   my $self = shift;
\&   return \*(Aqrun_mode_x\*(Aq;
\& }
.Ve
.PP
This would allow you to programmatically set the run mode based on arbitrary logic.
.PP
.Vb 4
\& $webapp\->mode_param(
\&        path_info=> 1,
\&        param =>\*(Aqrm\*(Aq
\& );
.Ve
.PP
This syntax allows you to easily set the run mode from \f(CW$ENV\fR{\s-1PATH_INFO\s0}.  It
will try to set the run mode from the first part of \f(CW$ENV\fR{\s-1PATH_INFO\s0} (before the
first \*(L"/\*(R"). To specify that you would rather get the run mode name from the 2nd
part of \f(CW$ENV\fR{\s-1PATH_INFO\s0}:
.PP
.Vb 1
\& $webapp\->mode_param( path_info=> 2 );
.Ve
.PP
This also demonstrates that you don't need to pass in the \f(CW\*(C`param\*(C'\fR hash key. It will
still default to \f(CW\*(C`rm\*(C'\fR.
.PP
You can also set \f(CW\*(C`path_info\*(C'\fR to a negative value. This works just like a negative
list index: if it is \-1 the run mode name will be taken from the last part of 
\&\f(CW$ENV\fR{\s-1PATH_INFO\s0}, if it is \-2, the one before that, and so on.
.PP
If no run mode is found in \f(CW$ENV\fR{\s-1PATH_INFO\s0}, it will fall back to looking in the
value of a the \s-1CGI\s0 form field defined with 'param', as described above.  This
allows you to use the convenient \f(CW$ENV\fR{\s-1PATH_INFO\s0} trick most of the time, but
also supports the edge cases, such as when you don't know what the run mode
will be ahead of time and want to define it with JavaScript.
.PP
\&\fBMore about \f(CB$ENV\fB{\s-1PATH_INFO\s0}\fR.
.PP
Using \f(CW$ENV\fR{\s-1PATH_INFO\s0} to name your run mode creates a clean separation between
the form variables you submit and how you determine the processing run mode. It
also creates URLs that are more search engine friendly. Let's look at an
example form submission using this syntax:
.PP
.Vb 2
\&        <form action="/cgi\-bin/instance.cgi/edit_form" method=post>
\&                <input type="hidden" name="breed_id" value="4">
.Ve
.PP
Here the run mode would be set to \*(L"edit_form\*(R". Here's another example with a
query string:
.PP
.Vb 1
\&        /cgi\-bin/instance.cgi/edit_form?breed_id=2
.Ve
.PP
This demonstrates that you can use \f(CW$ENV\fR{\s-1PATH_INFO\s0} and a query string together
without problems. \f(CW$ENV\fR{\s-1PATH_INFO\s0} is defined as part of the \s-1CGI\s0 specification
should be supported by any web server that supports \s-1CGI\s0 scripts.
.PP
\fI\fIprerun_mode()\fI\fR
.IX Subsection "prerun_mode()"
.PP
.Vb 1
\&    $webapp\->prerun_mode(\*(Aqnew_run_mode\*(Aq);
.Ve
.PP
The \fIprerun_mode()\fR method is an accessor/mutator which can be used within
your \fIcgiapp_prerun()\fR method to change the run mode which is about to be executed.
For example, consider:
.PP
.Vb 5
\&  # In WebApp.pm:
\&  package WebApp;
\&  use base \*(AqCGI::Application\*(Aq;
\&  sub cgiapp_prerun {
\&        my $self = shift;
\&
\&        # Get the web user name, if any
\&        my $q = $self\->query();
\&        my $user = $q\->remote_user();
\&
\&        # Redirect to login, if necessary
\&        unless ($user) {
\&                $self\->prerun_mode(\*(Aqlogin\*(Aq);
\&        }
\&  }
.Ve
.PP
In this example, the web user will be forced into the \*(L"login\*(R" run mode
unless they have already logged in.  The \fIprerun_mode()\fR method permits
a scalar text string to be set which overrides whatever the run mode
would otherwise be.
.PP
The use of \fIprerun_mode()\fR within \fIcgiapp_prerun()\fR differs from setting
\&\fImode_param()\fR to use a call-back via subroutine reference.  It differs
because \fIcgiapp_prerun()\fR allows you to selectively set the run mode based
on some logic in your \fIcgiapp_prerun()\fR method.  The call-back facility of
\&\fImode_param()\fR forces you to entirely replace CGI::Application's mechanism
for determining the run mode with your own method.  The \fIprerun_mode()\fR
method should be used in cases where you want to use CGI::Application's
normal run mode switching facility, but you want to make selective
changes to the mode under specific conditions.
.PP
\&\fBNote:\fR  The \fIprerun_mode()\fR method may \s-1ONLY\s0 be called in the context of
a \fIcgiapp_prerun()\fR method.  Your application will \fIdie()\fR if you call
\&\fIprerun_mode()\fR elsewhere, such as in \fIsetup()\fR or a run mode method.
.SS "Dispatching Clean URIs to run modes"
.IX Subsection "Dispatching Clean URIs to run modes"
Modern web frameworks dispense with cruft in URIs, providing in clean
URIs instead. Instead of:
.PP
.Vb 1
\& /cgi\-bin/item.cgi?rm=view&id=15
.Ve
.PP
A clean \s-1URI\s0 to describe the same resource might be:
.PP
.Vb 1
\& /item/15/view
.Ve
.PP
The process of mapping these URIs to run modes is called dispatching and is
handled by CGI::Application::Dispatch. Dispatching is not required and is a
layer you can fairly easily add to an application later.
.SS "Offline website development"
.IX Subsection "Offline website development"
You can work on your CGI::Application project on your desktop or laptop without
installing a full-featured web-server like Apache. Instead, install 
CGI::Application::Server from \s-1CPAN\s0. After a few minutes of setup, you'll
have your own private application server up and running.
.SS "Automated Testing"
.IX Subsection "Automated Testing"
There a couple of testing modules specifically made for CGI::Application.
.PP
Test::WWW::Mechanize::CGIApp allows functional testing of a CGI::App\-based project
without starting a web server. Test::WWW::Mechanize could be used to test the app
through a real web server.
.PP
Test::WWW::Selenium::CGIApp is similar, but uses Selenium for the testing,
meaning that a local web-browser would be used, allowing testing of websites
that contain JavaScript.
.PP
Direct testing is also easy. CGI::Application will normally print the output of it's
run modes directly to \s-1STDOUT\s0. This can be suppressed with an enviroment variable, 
\&\s-1CGI_APP_RETURN_ONLY\s0. For example:
.PP
.Vb 3
\&  $ENV{CGI_APP_RETURN_ONLY} = 1;
\&  $output = $webapp\->run();
\&  like($output, qr/good/, "output is good");
.Ve
.PP
Examples of this style can be seen in our own test suite.
.SH "PLUG-INS"
.IX Header "PLUG-INS"
CGI::Application has a plug-in architecture that is easy to use and easy
to develop new plug-ins for.
.SS "Recommended Plug-ins"
.IX Subsection "Recommended Plug-ins"
The following plugins are recommended for general purpose web/db development:
.IP "\(bu" 4
CGI::Application::Plugin::Redirect \- is a simple plugin to provide a shorter syntax for executing a redirect.
.IP "\(bu" 4
CGI::Application::Plugin::ConfigAuto \- Keeping your config details in a separate file is recommended for every project. This one integrates with Config::Auto. Several more config plugin options are listed below.
.IP "\(bu" 4
CGI::Application::Plugin::DBH \- Provides easy management of one or more database handles and can delay making the database connection until the moment it is actually used.
.IP "\(bu" 4
CGI::Application::Plugin::FillInForm \- makes it a breeze to fill in an \s-1HTML\s0 form from data originating from a \s-1CGI\s0 query or a database record.
.IP "\(bu" 4
CGI::Application::Plugin::Session \- For a project that requires session
management, this plugin provides a useful wrapper around CGI::Session
.IP "\(bu" 4
CGI::Application::Plugin::ValidateRM \- Integration with Data::FormValidator and HTML::FillInForm
.SS "More plug-ins"
.IX Subsection "More plug-ins"
Many more plugins are available as alternatives and for specific uses. For a
current complete list, please consult \s-1CPAN:\s0
.PP
http://search.cpan.org/search?m=dist&q=CGI%2DApplication%2DPlugin
.IP "\(bu" 4
CGI::Application::Plugin::AnyTemplate \- Use any templating system from within CGI::Application using a unified interface
.IP "\(bu" 4
CGI::Application::Plugin::Apache \- Use Apache::* modules without interference
.IP "\(bu" 4
CGI::Application::Plugin::AutoRunmode \- Automatically register runmodes
.IP "\(bu" 4
CGI::Application::Plugin::Config::Context \- Integration with Config::Context.
.IP "\(bu" 4
CGI::Application::Plugin::Config::General \- Integration with Config::General.
.IP "\(bu" 4
CGI::Application::Plugin::Config::Simple \- Integration with Config::Simple.
.IP "\(bu" 4
CGI::Application::Plugin::CompressGzip \- Add Gzip compression
.IP "\(bu" 4
CGI::Application::Plugin::LogDispatch \- Integration with Log::Dispatch
.IP "\(bu" 4
CGI::Application::Plugin::Stream \- Help stream files to the browser
.IP "\(bu" 4
CGI::Application::Plugin::TemplateRunner \- Allows for more of an ASP-style
code structure, with the difference that code and \s-1HTML\s0 for each screen are in
separate files.
.IP "\(bu" 4
CGI::Application::Plugin::TT \- Use Template::Toolkit as an alternative to HTML::Template.
.PP
Consult each plug-in for the exact usage syntax.
.SS "Writing Plug-ins"
.IX Subsection "Writing Plug-ins"
Writing plug-ins is simple. Simply create a new package, and export the
methods that you want to become part of a CGI::Application project. See
CGI::Application::Plugin::ValidateRM for an example.
.PP
In order to avoid namespace conflicts within a CGI::Application object,
plugin developers are recommended to use a unique prefix, such as the
name of plugin package, when storing information. For instance:
.PP
.Vb 3
\& $app\->{_\|_PARAM} = \*(Aqfoo\*(Aq; # BAD! Could conflict.
\& $app\->{\*(AqMyPlugin::Module::_\|_PARAM\*(Aq} = \*(Aqfoo\*(Aq; # Good.
\& $app\->{\*(AqMyPlugin::Module\*(Aq}{_\|_PARAM} = \*(Aqfoo\*(Aq; # Good.
.Ve
.SS "Writing Advanced Plug-ins \- Using callbacks"
.IX Subsection "Writing Advanced Plug-ins - Using callbacks"
When writing a plug-in, you may want some action to happen automatically at a
particular stage, such as setting up a database connection or initializing a
session. By using these 'callback' methods, you can register a subroutine
to run at a particular phase, accomplishing this goal.
.PP
\&\fBCallback Examples\fR
.PP
.Vb 3
\&  # register a callback to the standard CGI::Application hooks
\&  #   one of \*(Aqinit\*(Aq, \*(Aqprerun\*(Aq, \*(Aqpostrun\*(Aq, \*(Aqteardown\*(Aq or \*(Aqload_tmpl\*(Aq
\&  # As a plug\-in author, this is probably the only method you need.
\&
\&  # Class\-based: callback will persist for all runs of the application
\&  $class\->add_callback(\*(Aqinit\*(Aq, \e&some_other_method);
\&
\&  # Object\-based: callback will only last for lifetime of this object
\&  $self\->add_callback(\*(Aqprerun\*(Aq, \e&some_method);
\&
\&  # If you want to create a new hook location in your application,
\&  # You\*(Aqll need to know about the following two methods to create
\&  # the hook and call it.
\&
\&  # Create a new hook
\&  $self\->new_hook(\*(Aqpretemplate\*(Aq);
\&
\&  # Then later execute all the callbacks registered at this hook
\&  $self\->call_hook(\*(Aqpretemplate\*(Aq);
.Ve
.PP
\&\fBCallback Methods\fR
.PP
\fI\fIadd_callback()\fI\fR
.IX Subsection "add_callback()"
.PP
.Vb 2
\&        $self\->add_callback (\*(Aqteardown\*(Aq, \e&callback);
\&        $class\->add_callback(\*(Aqteardown\*(Aq, \*(Aqmethod\*(Aq);
.Ve
.PP
The add_callback method allows you to register a callback
function that is to be called at the given stage of execution.
Valid hooks include 'init', 'prerun', 'postrun' and 'teardown',
\&'load_tmpl', and any other hooks defined using the \f(CW\*(C`new_hook\*(C'\fR
method.
.PP
The callback should be a reference to a subroutine or the name of a
method.
.PP
If multiple callbacks are added to the same hook, they will all be
executed one after the other.  The exact order depends on which class
installed each callback, as described below under \fBCallback Ordering\fR.
.PP
Callbacks can either be \fIobject-based\fR or \fIclass-based\fR, depending
upon whether you call \f(CW\*(C`add_callback\*(C'\fR as an object method or a class
method:
.PP
.Vb 2
\&        # add object\-based callback
\&        $self\->add_callback(\*(Aqteardown\*(Aq, \e&callback);
\&
\&        # add class\-based callbacks
\&        $class\->add_callback(\*(Aqteardown\*(Aq, \e&callback);
\&        My::Project\->add_callback(\*(Aqteardown\*(Aq, \e&callback);
.Ve
.PP
Object-based callbacks are stored in your web application's \f(CW$c\fR
object; at the end of the request when the \f(CW$c\fR object goes out of
scope, the callbacks are gone too.
.PP
Object-based callbacks are useful for one-time tasks that apply only to
the current running application.  For instance you could install a
\&\f(CW\*(C`teardown\*(C'\fR callback to trigger a long-running process to execute at the
end of the current request, after all the \s-1HTML\s0 has been sent to the
browser.
.PP
Class-based callbacks survive for the duration of the running Perl
process.  (In a persistent environment such as \f(CW\*(C`mod_perl\*(C'\fR or
\&\f(CW\*(C`PersistentPerl\*(C'\fR, a single Perl process can serve many web requests.)
.PP
Class-based callbacks are useful for plugins to add features to all web
applications.
.PP
Another feature of class-based callbacks is that your plugin can create
hooks and add callbacks at any time \- even before the web application's
\&\f(CW$c\fR object has been initialized.  A good place to do this is in
your plugin's \f(CW\*(C`import\*(C'\fR subroutine:
.PP
.Vb 7
\&        package CGI::Application::Plugin::MyPlugin;
\&        use base \*(AqExporter\*(Aq;
\&        sub import {
\&                my $caller = scalar(caller);
\&                $caller\->add_callback(\*(Aqinit\*(Aq, \*(Aqmy_setup\*(Aq);
\&                goto &Exporter::import;
\&        }
.Ve
.PP
Notice that \f(CW\*(C`$caller\->add_callback\*(C'\fR installs the callback
on behalf of the module that contained the line:
.PP
.Vb 1
\&        use CGI::Application::Plugin::MyPlugin;
.Ve
.PP
\fInew_hook(\s-1HOOK\s0)\fR
.IX Subsection "new_hook(HOOK)"
.PP
.Vb 1
\&    $self\->new_hook(\*(Aqpretemplate\*(Aq);
.Ve
.PP
The \f(CW\*(C`new_hook()\*(C'\fR method can be used to create a new location for developers to
register callbacks.  It takes one argument, a hook name. The hook location is
created if it does not already exist. A true value is always returned.
.PP
For an example, CGI::Application::Plugin::TT adds hooks before and after every
template is processed.
.PP
See \f(CW\*(C`call_hook(HOOK)\*(C'\fR for more details about how hooks are called.
.PP
\fIcall_hook(\s-1HOOK\s0)\fR
.IX Subsection "call_hook(HOOK)"
.PP
.Vb 1
\&    $self\->call_hook(\*(Aqpretemplate\*(Aq, @args);
.Ve
.PP
The \f(CW\*(C`call_hook\*(C'\fR method is used to executed the callbacks that have been registered
at the given hook.  It is used in conjunction with the \f(CW\*(C`new_hook\*(C'\fR method which
allows you to create a new hook location.
.PP
The first argument to \f(CW\*(C`call_hook\*(C'\fR is the hook name. Any remaining arguments
are passed to every callback executed at the hook location. So, a stub for a 
callback at the 'pretemplate' hook would look like this:
.PP
.Vb 4
\& sub my_hook {
\&    my ($c,@args) = @_;
\&    # ....
\& }
.Ve
.PP
Note that hooks are semi-public locations. Calling a hook means executing
callbacks that were registered to that hook by the current object and also
those registered by any of the current object's parent classes.  See below for
the exact ordering.
.PP
\&\fBCallback Ordering\fR
.PP
Object-based callbacks are run before class-based callbacks.
.PP
The order of class-based callbacks is determined by the inheritance tree of the
running application. The built-in methods of \f(CW\*(C`cgiapp_init\*(C'\fR, \f(CW\*(C`cgiapp_prerun\*(C'\fR,
\&\f(CW\*(C`cgiapp_postrun\*(C'\fR, and \f(CW\*(C`teardown\*(C'\fR are also executed this way, according to the
ordering below.
.PP
In a persistent environment, there might be a lot of applications
in memory at the same time.  For instance:
.PP
.Vb 3
\&        CGI::Application
\&          Other::Project   # uses CGI::Application::Plugin::Baz
\&                 Other::App    # uses CGI::Application::Plugin::Bam
\&
\&          My::Project      # uses CGI::Application::Plugin::Foo
\&                 My::App       # uses CGI::Application::Plugin::Bar
.Ve
.PP
Suppose that each of the above plugins each added a callback to be run
at the 'init' stage:
.PP
.Vb 4
\&        Plugin                           init callback
\&        \-\-\-\-\-\-                           \-\-\-\-\-\-\-\-\-\-\-\-\-
\&        CGI::Application::Plugin::Baz    baz_startup
\&        CGI::Application::Plugin::Bam    bam_startup
\&
\&        CGI::Application::Plugin::Foo    foo_startup
\&        CGI::Application::Plugin::Bar    bar_startup
.Ve
.PP
When \f(CW\*(C`My::App\*(C'\fR runs, only \f(CW\*(C`foo_callback\*(C'\fR and \f(CW\*(C`bar_callback\*(C'\fR will
run.  The other callbacks are skipped.
.PP
The \f(CW@ISA\fR list of \f(CW\*(C`My::App\*(C'\fR is:
.PP
.Vb 3
\&        My::App
\&        My::Project
\&        CGI::Application
.Ve
.PP
This order determines the order of callbacks run.
.PP
When \f(CW\*(C`call_hook(\*(Aqinit\*(Aq)\*(C'\fR is run on a \f(CW\*(C`My::App\*(C'\fR application, callbacks
installed by these modules are run in order, resulting in:
\&\f(CW\*(C`bar_startup\*(C'\fR, \f(CW\*(C`foo_startup\*(C'\fR, and then finally \f(CW\*(C`cgiapp_init\*(C'\fR.
.PP
If a single class installs more than one callback at the same hook, then
these callbacks are run in the order they were registered (\s-1FIFO\s0).
.SH "COMMUNITY"
.IX Header "COMMUNITY"
Therese are primary resources available for those who wish to learn more
about CGI::Application and discuss it with others.
.PP
\&\fBWiki\fR
.PP
This is a community built and maintained resource that anyone is welcome to
contribute to. It contains a number of articles of its own and links
to many other CGI::Application related pages:
.PP
http://www.cgi\-app.org <http://www.cgi-app.org>
.PP
\&\fBSupport Mailing List\fR
.PP
If you have any questions, comments, bug reports or feature suggestions,
post them to the support mailing list!  To join the mailing list, simply
send a blank message to \*(L"cgiapp\-subscribe@lists.erlbaum.net\*(R".
.PP
\&\fB\s-1IRC\s0\fR
.PP
You can also drop by \f(CW\*(C`#cgiapp\*(C'\fR on \f(CW\*(C`irc.perl.org\*(C'\fR with a good chance of finding 
some people involved with the project there.
.PP
\&\fBSource Code\fR
.PP
This project is managed using git and is available on Github:
.PP
.Vb 1
\&    https://github.com/markstos/CGI\-\-Application
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "o" 4
.IX Item "o"
\&\s-1CGI\s0
.IP "o" 4
.IX Item "o"
HTML::Template
.IP "o" 4
.IX Item "o"
\&\fBCGI::Application::Framework\fR \- A full-featured web application based on
CGI::Application.  http://www.cafweb.org/
.SH "MORE READING"
.IX Header "MORE READING"
If you're interested in finding out more about CGI::Application, the
following articles are available on Perl.com:
.PP
.Vb 2
\&    Using CGI::Application
\&    http://www.perl.com/pub/a/2001/06/05/cgi.html
\&
\&    Rapid Website Development with CGI::Application
\&    http://www.perl.com/pub/a/2006/10/19/cgi_application.html
.Ve
.PP
Thanks to O'Reilly for publishing these articles, and for the incredible value
they provide to the Perl community!
.SH "AUTHOR"
.IX Header "AUTHOR"
Jesse Erlbaum <jesse@erlbaum.net>
.PP
Mark Stosberg has served as a co-maintainer since version 3.2, with the help of
the numerous contributors documented in the Changes file.
.SH "CREDITS"
.IX Header "CREDITS"
CGI::Application was originally developed by The Erlbaum Group, a software
engineering and consulting firm in New York City.
.PP
Thanks to Vanguard Media (http://www.vm.com) for funding the initial
development of this library and for encouraging Jesse Erlbaum to release it to
the world.
.PP
Many thanks to Sam Tregar (author of the most excellent
HTML::Template module!) for his innumerable contributions
to this module over the years, and most of all for getting
me off my ass to finally get this thing up on \s-1CPAN\s0!
.PP
Many other people have contributed specific suggestions or patches,
which are documented in the \f(CW\*(C`Changes\*(C'\fR file.
.PP
Thanks also to all the members of the CGI-App mailing list!
Your ideas, suggestions, insights (and criticism!) have helped
shape this module immeasurably.  (To join the mailing list, simply
send a blank message to \*(L"cgiapp\-subscribe@lists.erlbaum.net\*(R".)
.SH "LICENSE"
.IX Header "LICENSE"
CGI::Application : Framework for building reusable web-applications
Copyright (C) 2000\-2003 Jesse Erlbaum <jesse@erlbaum.net>
.PP
This module is free software; you can redistribute it and/or modify it
under the terms of either:
.PP
a) the \s-1GNU\s0 General Public License as published by the Free Software
Foundation; either version 1, or (at your option) any later version,
.PP
or
.PP
b) the \*(L"Artistic License\*(R" which comes with this module.
.PP
This program is distributed in the hope that it will be useful,
but \s-1WITHOUT\s0 \s-1ANY\s0 \s-1WARRANTY\s0; without even the implied warranty of
\&\s-1MERCHANTABILITY\s0 or \s-1FITNESS\s0 \s-1FOR\s0 A \s-1PARTICULAR\s0 \s-1PURPOSE\s0.  See either
the \s-1GNU\s0 General Public License or the Artistic License for more details.
.PP
You should have received a copy of the Artistic License with this
module, in the file \s-1ARTISTIC\s0.  If not, I'll be glad to provide one.
.PP
You should have received a copy of the \s-1GNU\s0 General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, \s-1MA\s0 02111\-1307
\&\s-1USA\s0
